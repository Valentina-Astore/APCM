TEST CHE SEMBRAVA PROMETTENTE (INTERESSANTE SE SI VUOLE CERCARE DI FARE UNA VERSIONE INTERMEDIA IN CUI I TERMINALI VENGONO APERTI IN AUTOMATICO)

Piglia il file TestT.java e portalo in APCM/Progettino

In APCM/Progettino compilalo a mano, non l'ho messo nel make: javac TestT.java 
Elimina e ricrea le pipes (riscrivo i comandi perché sennò è lunga scrivere ogni volta):

rm Java2CClient
rm Java2CServer
rm C2JavaClient
rm C2JavaServer

mkfifo Java2CClient
mkfifo Java2CServer
mkfifo C2JavaClient
mkfifo C2JavaServer

Poi lancia in terminali distinti: java Server, ./AES_CFB_DE Server, java TestT, java Client.

In teoria dovrebbe avere lo stesso comportamento di lanciare java Server, ./AES_CFB_DE Server, ./AES_CFB_ED, java Client solo aprendo un altro terminale






CARATTERISTICHE DELLA NUOVA VERSIONE (INTERESSANTE SE SI VUOLE CERCARE DI RISOLVERE IL BUG)
    - passato dai file EC/DE a quelli E/D
    
    - in AES_CBF.java ho aggiunto le seguenti righe di codice al lancio di ogni encryption/decryption:
    ######################
    try{
            ProcessBuilder p = new ProcessBuilder();

            p.command("bash", "-c", "gnome-terminal -- ./AES_CFB_ED " + id); //Lancio il comando mettendo id al posto di Client/Server

            Process process = p.start();
            
        }catch(IOException e){System.out.println("Error in opening ./AES_CFB_ED id");} 
    #######################

    - per fare il passo precedente ho bisogno di id. Quindi faccio in modo che Setup lo scriva in un attributo degli oggetti della classe (public string id)
    
    - modifico il make per compilare i nuovi file definiti. Ho anche tolto le dipendenze da LaunchThread
